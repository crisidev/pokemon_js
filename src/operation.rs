// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct EmptyOperationOperationInputWrapper(crate::input::EmptyOperationInput);
#[async_trait::async_trait]
impl<B> aws_smithy_http_server::request::FromRequest<B> for EmptyOperationOperationInputWrapper
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    async fn from_request(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        if let Some(headers) = req.headers() {
            if let Some(accept) = headers.get(http::header::ACCEPT) {
                if accept != "application/json" {
                    return Err(Self::Rejection {
                        protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                        kind:
                            aws_smithy_http_server::runtime_error::RuntimeErrorKind::NotAcceptable,
                    });
                }
            }
        }
        crate::operation_deser::parse_empty_operation_request(req)
            .await
            .map(EmptyOperationOperationInputWrapper)
            .map_err(|err| aws_smithy_http_server::runtime_error::RuntimeError {
                protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                kind: err.into(),
            })
    }
}
pub(crate) struct EmptyOperationOperationOutputWrapper(crate::output::EmptyOperationOutput);
#[async_trait::async_trait]
impl aws_smithy_http_server::response::IntoResponse for EmptyOperationOperationOutputWrapper {
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        match crate::operation_ser::serialize_empty_operation_response(self.0) {
            Ok(response) => response,
            Err(e) => aws_smithy_http_server::runtime_error::RuntimeError {
                protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                kind: e.into(),
            }
            .into_response(),
        }
    }
}
impl std::convert::From<crate::output::EmptyOperationOutput>
    for EmptyOperationOperationOutputWrapper
{
    fn from(o: crate::output::EmptyOperationOutput) -> Self {
        Self(o)
    }
}
impl std::convert::From<EmptyOperationOperationInputWrapper> for crate::input::EmptyOperationInput {
    fn from(i: EmptyOperationOperationInputWrapper) -> Self {
        i.0
    }
}

#[derive(Debug)]
pub(crate) struct GetPokemonSpeciesOperationInputWrapper(crate::input::GetPokemonSpeciesInput);
#[async_trait::async_trait]
impl<B> aws_smithy_http_server::request::FromRequest<B> for GetPokemonSpeciesOperationInputWrapper
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    async fn from_request(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        if let Some(headers) = req.headers() {
            if let Some(accept) = headers.get(http::header::ACCEPT) {
                if accept != "application/json" {
                    return Err(Self::Rejection {
                        protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                        kind:
                            aws_smithy_http_server::runtime_error::RuntimeErrorKind::NotAcceptable,
                    });
                }
            }
        }
        crate::operation_deser::parse_get_pokemon_species_request(req)
            .await
            .map(GetPokemonSpeciesOperationInputWrapper)
            .map_err(|err| aws_smithy_http_server::runtime_error::RuntimeError {
                protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                kind: err.into(),
            })
    }
}
pub(crate) enum GetPokemonSpeciesOperationOutputWrapper {
    Output(crate::output::GetPokemonSpeciesOutput),
    Error(crate::error::GetPokemonSpeciesError),
}
#[async_trait::async_trait]
impl aws_smithy_http_server::response::IntoResponse for GetPokemonSpeciesOperationOutputWrapper {
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_get_pokemon_species_response(o) {
                    Ok(response) => response,
                    Err(e) => aws_smithy_http_server::runtime_error::RuntimeError {
                        protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                        kind: e.into(),
                    }
                    .into_response(),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_get_pokemon_species_error(&err) {
                    Ok(mut response) => {
                        response.extensions_mut().insert(
                            aws_smithy_http_server::extension::ModeledErrorExtension::new(
                                err.name(),
                            ),
                        );
                        response
                    }
                    Err(e) => aws_smithy_http_server::runtime_error::RuntimeError {
                        protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                        kind: e.into(),
                    }
                    .into_response(),
                }
            }
        }
    }
}
impl
    std::convert::From<
        Result<crate::output::GetPokemonSpeciesOutput, crate::error::GetPokemonSpeciesError>,
    > for GetPokemonSpeciesOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::GetPokemonSpeciesOutput, crate::error::GetPokemonSpeciesError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl std::convert::From<GetPokemonSpeciesOperationInputWrapper>
    for crate::input::GetPokemonSpeciesInput
{
    fn from(i: GetPokemonSpeciesOperationInputWrapper) -> Self {
        i.0
    }
}

#[derive(Debug)]
pub(crate) struct GetServerStatisticsOperationInputWrapper(crate::input::GetServerStatisticsInput);
#[async_trait::async_trait]
impl<B> aws_smithy_http_server::request::FromRequest<B> for GetServerStatisticsOperationInputWrapper
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    async fn from_request(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        if let Some(headers) = req.headers() {
            if let Some(accept) = headers.get(http::header::ACCEPT) {
                if accept != "application/json" {
                    return Err(Self::Rejection {
                        protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                        kind:
                            aws_smithy_http_server::runtime_error::RuntimeErrorKind::NotAcceptable,
                    });
                }
            }
        }
        crate::operation_deser::parse_get_server_statistics_request(req)
            .await
            .map(GetServerStatisticsOperationInputWrapper)
            .map_err(|err| aws_smithy_http_server::runtime_error::RuntimeError {
                protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                kind: err.into(),
            })
    }
}
pub(crate) struct GetServerStatisticsOperationOutputWrapper(
    crate::output::GetServerStatisticsOutput,
);
#[async_trait::async_trait]
impl aws_smithy_http_server::response::IntoResponse for GetServerStatisticsOperationOutputWrapper {
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        match crate::operation_ser::serialize_get_server_statistics_response(self.0) {
            Ok(response) => response,
            Err(e) => aws_smithy_http_server::runtime_error::RuntimeError {
                protocol: aws_smithy_http_server::protocols::Protocol::RestJson1,
                kind: e.into(),
            }
            .into_response(),
        }
    }
}
impl std::convert::From<crate::output::GetServerStatisticsOutput>
    for GetServerStatisticsOperationOutputWrapper
{
    fn from(o: crate::output::GetServerStatisticsOutput) -> Self {
        Self(o)
    }
}
impl std::convert::From<GetServerStatisticsOperationInputWrapper>
    for crate::input::GetServerStatisticsInput
{
    fn from(i: GetServerStatisticsOperationInputWrapper) -> Self {
        i.0
    }
}
